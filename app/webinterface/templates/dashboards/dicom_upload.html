{% extends "dashboards/dashboards.html" %}

{% block extra_head %}
<script type="text/javascript" src="https://unpkg.com/dicomweb-client"></script>
<style>
.upload-box {
    border: 2px dashed #dbdbdb;
    border-radius: 4px;
    padding: 2rem;
    text-align: center;
    margin-bottom: 1rem;
}

.upload-box.is-dragover {
    border-color: #00d1b2;
    background: rgba(0,209,178,0.1);
}

.progress-container {
    margin: 2rem 0;
    display: none;
}

.upload-status {
    margin-top: 1rem;
    text-align: center;
    display: none;
}
</style>
{% endblock %}

{% block dashboard_content %}
<div class="container">
    <h2 class="title is-4">DICOM Upload</h2>
    <form id="dicom-upload-form">
    <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label">Force Rule</label>
        </div>
        <div class="field-body">
          <div class="field">
            <div class="control is-expanded">
              <div class="select">
                  <select id="force-rule-input" name="force_rule" >
                    <option value=""></option>
                    {% for rule in rules %}
                    <option>{{ rule }}</option>
                    {% endfor %}
                  </select>
                </div>
            </div>
          </div>
        </div>
      </div>

    <!-- input checkbox for save_dataset -->
      <div class="field is-horizontal"> 
        <div class="field-label is-normal">
          <label class="label">Save Dataset</label>
        </div>
        <div class="field-body">
          <div class="field">
            <div class="control">
                <!-- Onchange handler to disable/enable dataset-name input -->
              <input id="save_dataset" name="save_dataset" type="checkbox" value="true" onchange="$('#dataset-name').attr('disabled', !this.checked)">
            </div>
          </div>
        </div>
      </div>

     <div class="field is-horizontal">
        <div class="field-label is-normal">
          <label class="label">Dataset Name</label>
        </div>
        <div class="field-body">
          <div class="field">
            <div class="control is-expanded">
              <input id="dataset-name" name="dataset_name" type="text" placeholder="Enter dataset name" class="input" disabled>
            </div>
          </div>
        </div>
      </div>
    </form>
    <div class="columns">
        <div class="column is-8">
            <div id="upload-box" class="upload-box">
                <div class="file has-name is-boxed is-centered">
                    <label class="file-label">
                        <input class="file-input" type="file" id="file-input" multiple accept=".dcm,.zip">
                        <span class="file-cta">
                            <span class="file-icon">
                                <i class="fas fa-upload"></i>
                            </span>
                            <span class="file-label">
                                Choose files or drag here...
                            </span>
                        </span>
                    </label>
                </div>
            </div>

            <div class="progress-container">
                <progress class="progress is-primary" id="upload-progress" value="0" max="100"></progress>
                <p class="has-text-centered" id="progress-text">Uploading files...</p>
            </div>

            <!-- <div class="upload-status" id="upload-status">
                <span class="icon is-large">
                    <i class="fas fa-2x"></i>
                </span>
                <p class="is-size-5 mt-2"></p>
            </div>
 -->
            <div class="field is-grouped" style="margin-top: 1rem;">
                <div class="control">
                    <button class="button is-primary" id="upload-btn" disabled>
                        <span class="icon">
                            <i class="fas fa-upload"></i>
                        </span>
                        <span>Upload Files</span>
                    </button>
                </div>
                <div class="control">
                    <button class="button is-light" id="clear-btn" disabled>
                        <span class="icon">
                            <i class="fas fa-times"></i>
                        </span>
                        <span>Clear</span>
                    </button>
                </div>
            </div>
        </div>

        <div class="column">
            <div class="notification is-info is-light">
                <h4 class="title is-5">Upload Information</h4>
                <p>Selected files: <strong id="file-count">0</strong></p>
                <p>Total size: <strong id="total-size">0 KB</strong></p>
            </div>
        </div>
    </div>
    <div class="columns">
        <div class="column is-full">
            <!-- Table of datasets with actions-->
               
            <table class="table is-fullwidth">
                <tbody>
                    {% for dataset in datasets %}
                    <tr>
                        <td>{{ dataset }}</td>
                        <td>
                            <button class="button is-small is-info" onclick="window.submitDataset('{{ dataset }}')">Submit</button>
                            <button class="button is-small is-danger" onclick="window.deleteDataset('{{ dataset }}')">Delete</button>
                        </td>
                    </tr>
                    {% endfor %}
                </tbody>
            </table>
        </div>
    </div>

</div>

<script>
async function submitDataset(dataset) {
    if (!confirm("Submit dataset " + dataset + "?")) {
        return;
    }
    // urelencode dataset

    result = await fetch('/tools/dataset/'+encodeURIComponent(dataset), { method: 'POST' });
    if (result.ok) {
        alert("Dataset " + dataset + " submitted successfully!");
        location.reload();
    } else {
        alert("Failed to submit dataset " + dataset);
    }
}
async function deleteDataset(dataset) {
    if (!confirm("Delete dataset " + dataset + "?")) {
        return;
    }
    result = await fetch('/tools/dataset/'+encodeURIComponent(dataset), { method: 'DELETE' });
    if (result.ok) {
        alert("Dataset " + dataset + " deleted successfully!");
        location.reload();
    } else {
        alert("Failed to delete dataset " + dataset);
    }
}
$(document).ready(function() {
    const MAX_RETRIES = 3;
    const RETRY_DELAY = 2000; // 2 seconds

    const uploadBox = $('#upload-box');
    const fileInput = $('#file-input');
    const uploadBtn = $('#upload-btn');
    const clearBtn = $('#clear-btn');
    const fileCount = $('#file-count');
    const totalSize = $('#total-size');
    const progressBar = $('#upload-progress');
    const progressText = $('#progress-text');
    const progressContainer = $('.progress-container');
    const uploadStatus = $('#upload-status');

    let files = new Map();

    // Drag and drop handling
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        uploadBox.on(eventName, preventDefaults);
    });

    function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
    }

    ['dragenter', 'dragover'].forEach(eventName => {
        uploadBox.on(eventName, () => uploadBox.addClass('is-dragover'));
    });

    ['dragleave', 'drop'].forEach(eventName => {
        uploadBox.on(eventName, () => uploadBox.removeClass('is-dragover'));
    });

    uploadBox.on('drop', handleDrop);
    fileInput.on('change', handleFiles);

    function handleDrop(e) {
        const dt = e.originalEvent.dataTransfer;
        const droppedFiles = dt.files;
        handleFiles({ target: { files: droppedFiles } });
    }

    function handleFiles(e) {
        files.clear();
        Array.from(e.target.files).forEach(file => {
            files.set(file.name, {
                file: file,
                status: 'Pending'
            });
        });
        updateStats();
        updateButtons();
        hideStatus();
    }

    function updateStats() {
        fileCount.text(files.size);
        const total = Array.from(files.values()).reduce((acc, curr) => acc + curr.file.size, 0);
        totalSize.text(formatSize(total));
    }

    function updateButtons() {
        uploadBtn.prop('disabled', files.size === 0);
        clearBtn.prop('disabled', files.size === 0);
    }

    function formatSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }
    
function guid() {
  function s4() {
    return Math.floor((1 + Math.random()) * 0x10000)
      .toString(16)
      .substring(1);
  }
  return `${s4() + s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
}

function multipartEncode(
  datasets,
  boundary = guid(),
  contentType = 'application/dicom',
) {
//   const contentTypeString = `Content-Type: ${contentType}`;
  const header = (dataContentType) => 
    `\r\n--${boundary}\r\nContent-Type: ${dataContentType}\r\n\r\n`;

//   const header = `\r\n--${boundary}\r\n${contentTypeString}\r\n\r\n`;
  const footer = `\r\n--${boundary}--`;
  const encoder = new TextEncoder()
  const footerArray = encoder.encode(footer);
  const footerLength = footerArray.length;

  let length = 0;

  // Calculate the total length for the final array
  const contentArrays = datasets.map(dataset => {
    let contentArray;
    let dataContentType;

    if (dataset instanceof URLSearchParams) {
      dataContentType = 'application/x-www-form-urlencoded';
      contentArray = encoder.encode(dataset.toString());
    } else {
      dataContentType = contentType;
      contentArray = new Uint8Array(dataset);
    }
    const headerArray = encoder.encode(header(dataContentType));
    const headerLength = headerArray.length;
    const contentLength = contentArray.length;


    length += headerLength + contentLength + footerLength;

    return {
      headerArray,
      contentArray,
      headerLength,
      contentLength,
    };
  });

  // Allocate the array
  const multipartArray = new Uint8Array(length);

  // Set the initial header
  multipartArray.set(encoder.encode(header(contentType)), 0);

  // Write each dataset into the multipart array
  let position = 0;
  contentArrays.forEach(({ headerArray, contentArray, headerLength, contentLength }) => {
    multipartArray.set(headerArray, position);
    multipartArray.set(contentArray, position + headerLength);
    position += headerLength + contentArray.length;
  });

  multipartArray.set(footerArray, position);

  return {
    data: multipartArray.buffer,
    boundary,
  };
}
function objectToURLSearchParams(obj) {
  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(obj)) {
    if (value !== undefined && value !== null) {
      params.append(key, value.toString());
    }
  }
  return params;
}

function uploadData(url, data, contentType, callback) {
    return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();

        // Convert data to appropriate format if needed

        // Upload progress event
        xhr.upload.addEventListener('progress', callback);
        xhr.upload.addEventListener('error', () => reject('Upload error'));
        xhr.addEventListener('load', () => resolve(xhr.response));
        xhr.addEventListener('error', () => reject(xhr.statusText));

        xhr.open('POST', url, true);
        xhr.setRequestHeader('Content-Type', contentType);
        xhr.send(data);
    });
}

async function storeInstances(datasets, options, progressCallback) {
    datasets.push(objectToURLSearchParams(options))
    const { data, boundary } = multipartEncode(datasets);
    const url = "/tools/upload/store";
    return await uploadData(url, data, `multipart/related; type="application/dicom"; boundary="${boundary}"`, progressCallback)
}
function stringToUint8Array(str) {
  return Uint8Array.from(Array.from(text).map(letter => letter.charCodeAt(0)));
}

async function uploadWithRetry(files, retries = 0) {
    // Create FormData object
    const formData = new FormData(document.getElementById('dicom-upload-form'));
    const formObject = Object.fromEntries(formData);
    if (!retries) {
        result = await fetch('/tools/dataset/'+encodeURIComponent(formObject.dataset_name), { method: 'GET' });
        if (result.ok) {
            throw new Error("A dataset with this name already exists. Please choose another name.");
        }
    }
    try {
        const force_rule = $("#force-rule-input").val()

        const request = new XMLHttpRequest();
        const progressCallback = evt => {
            if (!evt.lengthComputable) {
                $('#upload-progress').removeAttr('value');
            }
            const percentComplete = Math.round((100 * evt.loaded) / evt.total);
            $('#upload-progress').val(percentComplete);
        };

        // Add the progress callback as a listener to the request upload object.
        // await 
        await storeInstances(Array.from(files.values()).map(f => f.binary), formObject, progressCallback);
        window.location.reload();
        // result = await client.storeInstances({datasets: Array.from(files.values()).map(f => f.binary), request:request});
    } catch (error) {
        console.error(error);
        if (retries < MAX_RETRIES) {
            await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
            return uploadWithRetry(files, retries + 1);
        }
        throw error;
    }
}

    function showStatus(success, message) {
        // uploadStatus.find('i')
        //     .removeClass('fa-check-circle fa-times-circle has-text-success has-text-danger')
        //     .addClass(success ? 'fa-check-circle has-text-success' : 'fa-times-circle has-text-danger');
        uploadStatus.find('p').text(message);
        uploadStatus.show();
    }

    function hideStatus() {
        uploadStatus.hide();
    }

    uploadBtn.click(async function() {
        uploadBtn.addClass('is-loading').prop('disabled', true);
        clearBtn.prop('disabled', true);
        progressContainer.show();
        hideStatus();

        try {
            progressBar.val('');
            progressText.text('Preparing files for upload...');
            progressBar.val(0);

            // Create array of promises for reading files
            const fileReadPromises = Array.from(files.values()).map(fileData => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = () => resolve(reader.result);
                    reader.onerror = () => reject(reader.error);
                    reader.readAsArrayBuffer(fileData.file);
                });
            });

            // Wait for all files to be read
            const fileContents = await Promise.all(fileReadPromises);
            
            // Update files map with binary content
            let i = 0;
            for (const [fileName, fileData] of files) {
                fileData.binary = fileContents[i++];
            }

            progressText.text('Uploading files...');
            await uploadWithRetry(files);
            
            // Success handling
            showStatus(true, 'All files uploaded successfully!');
            files.clear();
            updateStats();
            progressBar.val(100);

        } catch (error) {
            showStatus(false, `Upload failed: ${error.message}`);
            console.error('Upload error:', error);
            alert('Upload failed: ' + error.message);
        } finally {
            progressContainer.hide();
            uploadBtn.removeClass('is-loading');
            updateButtons();
        }
    });




    clearBtn.click(function() {
        files.clear();
        updateStats();
        updateButtons();
        hideStatus();
        progressContainer.hide();
        progressBar.val(0);
    });
});
</script>
{% endblock %}